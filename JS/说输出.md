### 作用域
#### 1 ????
```js
var x=1,y=2;
var z=function() {
  var x= 2
  return {
    x: x,
    y: function(a,b) {
      x=a+b;
      // console.log("y");
      // console.log(x);
    },
    z: function() {
      // console.log("z");
      // console.log(x);
      return x;
    }
  }
};

a=z();
// console.log(a);
a.y(x,y);
// console.log(a);
console.log(x);
console.log(a.z(),a.x,x);

---
3 2 1
```

#### 2
```js
var a = 1;
function fn1() {
    function fn3() {
        var fn2 = function () {
            console.log(a);
        }
        fn2();
        a = 4;
    }
    var a = 2;
    return fn3;
}
var fn = fn1();
fn();   //2
```
```js
var a = 1;
function fn1() {
     function fn3() {
           var a = 4;
           fn2();
     }
     var a = 2;
     return fn3;
}
function fn2() {
 console.log(a);
}
var fn = fn1();
fn();   //1
```
作者：水桶侏儒猪😘
链接：https://www.nowcoder.com/discuss/612971?channel=-1&source_id=profile_follow_post_nctrack
来源：牛客网

考察的是函数作用域问题 这二个输出为1的，因为fn2所在为全局作用域，所以即使在内部调用，也是输出所在作用域的a，第一道题中，a=4没有用var来定义，则此时a自动提成为全局变量，所以此时输出的是fn3中的a =2

#### 3
```js
var friendName = 'World';
(function() {
  if (typeof friendName === 'undefined') {
    var friendName = 'Jack';
    console.log('Goodbye ' + friendName);
  } else {
    console.log('Hello ' + friendName);
  }
})();
```

等于
```js
var name = 'World!';
(function () {
    var name;
    if (typeof name === 'undefined') {
        name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();

// Goodbye Jack
```
>注意：即使是**if语句中的var也会变量提升**
>**所以遇到if先看里面有没有变量声明**

#### 4
```js
(function(){
   var x = y = 1;
})();
var z;

console.log(y); 
console.log(z); 
console.log(x); 
```

这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。

>注意：**全局引用局部变量会报错而不是输出undefined**。

```js
// 1
// undefined
// Uncaught ReferenceError: x is not defined
```

#### 5
```js
 var a=3;
 function c(){
    alert(a);
 }
 (function(){
  var a=4;
  c();
 })();
 ```

 js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等

>c的作用域是全局，不管是谁调用的他。

```3```

#### 6
```js
function fun(n, o) {
  console.log(o)
  return {
    fun: function(m){
      return fun(m, n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);
```

这是一道关于**闭包**的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 console.log(o); 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。

```js
undefined  0  0  0
undefined  0  1  2
undefined  0  1  1
```

#### 7
```js
f = function() {return true;};   
g = function() {return false;};   
(function() {   
  // 实际上会报错，加上下面这行才不会
  //  function g() {return true;}  
   if (g() && [] == ![]) {   
      f = function f() {return false;};   
      function g() {return true;}   
   }   
})();   
console.log(f());
console.log(g());
```

这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。

第二个条件是[] == ![]，先看 **![]** ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 **[] 被视为 true**, 而 **![] 的结果就是 false 了**。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 `''` ，而 `''` 会被当作 0 ，所以，条件成立。

两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。（？？报错）

>注意：**函数声明**（`function g() {return true;} `）等同于var声明，都是**声明局部变量**。

---
参考
```js
f = function() {return true;};   
var g = 4;
(function() {   
   console.log(g);
   if (g === undefined && [] == ![]) {   
      f = function f() {return false;};   
      var g = 3
   }   
})();   
console.log(f());

// undefined
// false
```

>说明函数作用域中变量可以提升

和
```js
(function() {   
   console.log(g);
   function g() {return true;}; 
})();   

// ƒ g() {return true;}
```

>说明函数作用域中函数也可以提升

而
```js
f = function() {return true;};   
g = function() {return false;};   
(function() {   
  console.log(g);
  console.log(j);
   if ([] == ![]) {   
      f = function f() {return false;};   
      function g() {return true;}   
      var j = 3
   }   
})();   
console.log(f());
console.log(g());

// undefined
// undefined
// false
// false
```

>说明**if语句中的函数声明**也不会变为引用，**和变量一样赋值为undefined**

>(?)**if 条件句中的 function 会被编译成 函数表达式**, 声明会被提升到当前作用域的最顶部, 但是赋值会被留在原地. 

#### 8

见 [作用域](./作用域.md#默认绑定)

### this
#### 1 !!!!
```js
window.number = 2;
var obj = {
 number: 3,
 db1: (function(){
   console.log(this);
   this.number *= 4;
   return function(){
     console.log(this);
     this.number *= 5;
   }
 })()
}
var db1 = obj.db1;
db1();
obj.db1();
console.log(obj.number);     
console.log(window.number); 
```

这道题目看清起来有点乱，但是实际上是考察this指向的:
1. 执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；
2. 执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。

>**注意立即执行函数返回是一个值**，这里`obj.db1();`实际上()执行的是返回的那个function()，而obj.db1本身代表
```js
   return function(){
     console.log(this);
     this.number *= 5;
   }
```
>这个函数而不是外面那个立即执行函数。

>**立即执行函数只会被调用一次。!!!!!** 之后就销毁，只剩下返回的值。
```js
// 结果
// 15
// 40
```

#### 2
```js
var a = 1;
function printA(){
  console.log(this.a);
}
var obj={
  a:2,
  foo:printA,
  bar:function(){
    printA();
  }
}

obj.foo();
obj.bar(); 
var foo = obj.foo;
foo(); 
```

解析：
1. obj.foo()，foo 的this指向obj对象，所以a会输出2；
   >注意这里的`. 和 ()`是写在obj后面的，也就是obj调用的，所以this指向obj
2. obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；
3. foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；

```js
// 2 1 1
```

### 异步
#### 1
```js
const p1=new Promise((resolve, reject)=>{
  setTimeout(() => {
    resolve(1)
    throw new Error(2)
  }, 2000);
})
const p2 = p1.then(val=>{
  console.log(val);
  return val + 1
}).catch(err=>{
  console.log(err);
  return err
})
Promise.all([p2, Promise.reject(3).then(val2=>{
  console.log(val2);
})]).catch(err2=>{
  console.log(err2);
})

---
// 3
// Uncaught Error: 2
// 1
```

#### 2 !!!!
```js
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise1')
  })
}, 0)
const timer2 = setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)

// timer1
// promise1
// timer2
// promise2
```
```js
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');

---
start
promise1
timer1
promise2
timer2
```
??  每个setTimeout单独构成一次宏任务队列，而不是都加到任务队列一起处理
**每个settimeout之后执行自己的微任务**

### 原型

#### 1

```js
function Person(name) {
    this.name = name
}
var p2 = new Person('king');
console.log(p2.__proto__) //Person.prototype
console.log(p2.__proto__.__proto__) //Object.prototype
console.log(p2.__proto__.__proto__.__proto__) // null
console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
console.log(p2.constructor)//Person. 是p2.__proto__.constructor
console.log(p2.prototype)//undefined p2是实例，没有prototype属性
console.log(Person.constructor)//Function 一个空函数。 是Person.__proto__.constructor
console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性（它里面除了`__proto__`只有`constructor: ƒ Person(name)`）
console.log(Person.prototype.constructor)//Person
console.log(Person.prototype.__proto__)// Object.prototype
console.log(Person.__proto__) //Function.prototype
console.log(Function.prototype.__proto__)//Object.prototype
console.log(Function.__proto__)//Function.prototype
console.log(Object.__proto__)//Function.prototype
console.log(Object.prototype.__proto__)//null
```

>所有的函数（包括Function和Object）的`__proto__`都是Function.prototype

#### 2

```js {.line-numbers}
function Parent() {
    this.a = 1;
    this.b = [1, 2, this.a];
    this.c = { demo: 5 };
    this.show = function () {
        console.log(this.a , this.b , this.c.demo );
    }
}

function Child() {
    this.a = 2;
    this.change = function () {
        this.b.push(this.a);
        this.a = this.b.length;
        this.c.demo = this.a++;
    }
}

Child.prototype = new Parent();
var parent = new Parent();
var child1 = new Child();
var child2 = new Child();
child1.a = 11;
child2.a = 12;
parent.show();
child1.show();
child2.show();
child1.change();
child2.change();
parent.show();
child1.show();
child2.show();
```

涉及到的知识点很多，例如this的指向、原型、原型链、类的继承、数据类型等。

解析：
1. parent.show()，可以直接获得所需的值，没啥好说的；
   
2. child1.show()，Child的构造函数原本是指向Child的，题目显式将Child类的原型对象指向了Parent类的一个实例，需要注意Child.prototype指向的是Parent的实例parent，而不是指向Parent这个类。
   
3. child2.show()，这个也没啥好说的；
   
4. parent.show()，parent是一个Parent类的实例，Child.prorotype指向的是Parent类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响parent实例，所以输出结果不变；
   
5. child1.show()，child1执行了change()方法后，发生了怎样的变化呢?
   
- this.b.push(this.a)，由于this的动态指向特性，**this.b会指向Child.prototype上的b数组**,this.a会指向child1的a属性,所以Child.prototype.b变成了`[1,2,1,11]`;
  
- this.a = this.b.length，这条语句中this.a和this.b的指向与上一句一致，故结果为child1.a变为4;
  
- this.c.demo = this.a++，由于child1自身属性并没有c这个属性，所以此处的this.c会指向Child.prototype.c，this.a值为4，为原始类型，故赋值操作时会直接赋值，Child.prototype.c.demo的结果为4，而this.a随后自增为5(4 + 1 = 5)。
  
6. child2执行了change()方法, 而child2和child1均是Child类的实例，所以他们的原型链指向同一个原型对象Child.prototype,也就是同一个parent实例，所以child2.change()中所有影响到原型对象的语句都会影响child1的最终输出结果。
   
- this.b.push(this.a)，由于this的动态指向特性，this.b会指向Child.prototype上的b数组,this.a会指向child2的a属性,所以Child.prototype.b变成了`[1,2,1,11,12]`;
  
- this.a = this.b.length，这条语句中this.a和this.b的指向与上一句一致，故结果为child2.a变为5;
  
- this.c.demo = this.a++，由于child2自身属性并没有c这个属性，所以此处的this.c会指向Child.prototype.c，故执行结果为Child.prototype.c.demo的值变为child2.a的值5，而child2.a最终自增为6(5 + 1 = 6)。

>主要在于28行调用的，第13行的这个this.b，实际上这里的this还是指向这个child1，他只有一个a属性。但是this代表了这个child1，**找`.b`的属性的时候还是会顺着原型链找**，所以才找到了那个Parent实例的属性。

```js
parent.show(); // 1  [1,2,1] 5

child1.show(); // 11 [1,2,1] 5
child2.show(); // 12 [1,2,1] 5

parent.show(); // 1 [1,2,1] 5

child1.show(); // 5 [1,2,1,11,12] 5

child2.show(); // 6 [1,2,1,11,12] 5
```

### 数组
```js
let arr=[1,2,3]
let brr=arr.push(4)
let crr=arr.splice(1,1,)
console.log(arr)
console.log(brr)
console.log(crr)

---
[1, 3, 4]
4   //pusha返回的是数组长度，pop返回的是弹出的元素
[2]
```