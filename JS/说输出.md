### 作用域
#### 1 ????
```js
var x=1,y=2;
var z=function() {
  var x= 2
  return {
    x: x,
    y: function(a,b) {
      x=a+b;
      // console.log("y");
      // console.log(x);
    },
    z: function() {
      // console.log("z");
      // console.log(x);
      return x;
    }
  }
};

a=z();
// console.log(a);
a.y(x,y);
// console.log(a);
console.log(x);
console.log(a.z(),a.x,x);

---
3 2 1
```

#### 2
```js
var a = 1;
function fn1() {
    function fn3() {
        var fn2 = function () {
            console.log(a);
        }
        fn2();
        a = 4;
    }
    var a = 2;
    return fn3;
}
var fn = fn1();
fn();   //2
```
```js
var a = 1;
function fn1() {
     function fn3() {
           var a = 4;
           fn2();
     }
     var a = 2;
     return fn3;
}
function fn2() {
 console.log(a);
}
var fn = fn1();
fn();   //1
```
作者：水桶侏儒猪😘
链接：https://www.nowcoder.com/discuss/612971?channel=-1&source_id=profile_follow_post_nctrack
来源：牛客网

考察的是函数作用域问题 这二个输出为1的，因为fn2所在为全局作用域，所以即使在内部调用，也是输出所在作用域的a，第一道题中，a=4没有用var来定义，则此时a自动提成为全局变量，所以此时输出的是fn3中的a =2

#### 3
```js
var friendName = 'World';
(function() {
  if (typeof friendName === 'undefined') {
    var friendName = 'Jack';
    console.log('Goodbye ' + friendName);
  } else {
    console.log('Hello ' + friendName);
  }
})();
```

等于
```js
var name = 'World!';
(function () {
    var name;
    if (typeof name === 'undefined') {
        name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();

// Goodbye Jack
```
>注意：即使是**if语句中的var也会变量提升**
>**所以遇到if先看里面有没有变量声明**

#### 4
```js
(function(){
   var x = y = 1;
})();
var z;

console.log(y); 
console.log(z); 
console.log(x); 
```

这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。

>注意：**全局引用局部变量会报错而不是输出undefined**。

```js
// 1
// undefined
// Uncaught ReferenceError: x is not defined
```

#### 5
```js
 var a=3;
 function c(){
    alert(a);
 }
 (function(){
  var a=4;
  c();
 })();
 ```

 js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等

>c的作用域是全局，不管是谁调用的他。

```3```

#### 6
```js
function fun(n, o) {
  console.log(o)
  return {
    fun: function(m){
      return fun(m, n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);
```

这是一道关于**闭包**的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 console.log(o); 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。

```js
undefined  0  0  0
undefined  0  1  2
undefined  0  1  1
```

#### 7
```js
f = function() {return true;};   
g = function() {return false;};   
(function() {   
  // 实际上会报错，加上下面这行才不会
  //  function g() {return true;}  
   if (g() && [] == ![]) {   
      f = function f() {return false;};   
      function g() {return true;}   
   }   
})();   
console.log(f());
console.log(g());
```

这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。

第二个条件是[] == ![]，先看 **![]** ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 **[] 被视为 true**, 而 **![] 的结果就是 false 了**。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 `''` ，而 `''` 会被当作 0 ，所以，条件成立。

两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。（？？报错）

>注意：**函数声明**（`function g() {return true;} `）等同于var声明，都是**声明局部变量**。

---
参考
```js
f = function() {return true;};   
var g = 4;
(function() {   
   console.log(g);
   if (g === undefined && [] == ![]) {   
      f = function f() {return false;};   
      var g = 3
   }   
})();   
console.log(f());

// undefined
// false
```

>说明函数作用域中变量可以提升

和
```js
(function() {   
   console.log(g);
   function g() {return true;}; 
})();   

// ƒ g() {return true;}
```

>说明函数作用域中函数也可以提升

而
```js
f = function() {return true;};   
g = function() {return false;};   
(function() {   
  console.log(g);
  console.log(j);
   if ([] == ![]) {   
      f = function f() {return false;};   
      function g() {return true;}   
      var j = 3
   }   
})();   
console.log(f());
console.log(g());

// undefined
// undefined
// false
// false
```

>说明**if语句中的函数声明**也不会变为引用，**和变量一样赋值为undefined**

>(?)**if 条件句中的 function 会被编译成 函数表达式**, 声明会被提升到当前作用域的最顶部, 但是赋值会被留在原地. 

#### 8

见 [作用域](./作用域.md#默认绑定)

#### 9
```js
'use strict';
var b = 2;
if (true) {
 let a = 2;
 var b = 3;
 var c = 4;
 const d = 5;
}
console.log(a);
console.log(b); 
console.log(c);
console.log(d);
var d = 6;
```

注意，块级作用域指的只是**该变量自己**，不影响其他变量。
这里虽然let在if的块级作用域里，但是其他的var声明的变量还是会提升

```js
VM239:9 Uncaught ReferenceError: a is not defined //不管是否strict都报错，然后停止执行
// 如果忽略a的错误
3 4 undefined
```

#### 10

```js
var b = 'window';
function c() {
  console.log(b)
  console.log(this.b)
}

var obj = {
    b: '1-1',
    c:function(){
      console.log(b)
      console.log(this.b)
      return {
        b: '1-2',
        c: function() {
          console.log(b)
          console.log(this.b)
        }
      }
    },
}
c()
obj = obj.c()
obj.c = c
obj.c()
```

注意审题

```
window
window
window
1-1
window
1-2
```

#### 11 !! 
```js
// let x = 5;
function setFn() {
  var x  =  0;
  return function() { 
    x = x + 1; 
    return x;
  };
}

const f1 = setFn();
const f2 = setFn();

f1(); // 1
f2(); // 1

f1(); // 2
f2(); // 2

const f3 = setFn();
const obj = {x: 10};

f3.call(obj); // 1
```

闭包函数**每次调用形成一个自己的闭包变量**，和别人不相干
？这里应该是考察的作用域，call改变的是this，所以和this无关

### this
#### 1 !!!!
```js
window.number = 2;
var obj = {
 number: 3,
 db1: (function(){
   console.log(this);
   this.number *= 4;
   return function(){
     console.log(this);
     this.number *= 5;
   }
 })()
}
var db1 = obj.db1;
db1();
obj.db1();
console.log(obj.number);     
console.log(window.number); 
```

这道题目看清起来有点乱，但是实际上是考察this指向的:
1. 执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；
>注意，在定义`var obj`的时候db1的立即执行函数已经被执行了，而不是下面执行db1();的时候才执行。
2. 执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。

>**注意立即执行函数返回是一个值**，这里`obj.db1();`实际上()执行的是返回的那个function()，而obj.db1本身代表
```js
   return function(){
     console.log(this);
     this.number *= 5;
   }
```
>这个函数而不是外面那个立即执行函数。

>**立即执行函数只会被调用一次。!!!!!** 之后就销毁，只剩下返回的值。
```js
// Window
// 15
// 40
```

#### 2
```js
var a = 1;
function printA(){
  console.log(this.a);
}
var obj={
  a:2,
  foo:printA,
  bar:function(){
    printA();
  }
}

obj.foo();
obj.bar(); 
var foo = obj.foo;
foo(); 
```

解析：
1. obj.foo()，foo 的this指向obj对象，所以a会输出2；
   >注意这里的`. 和 ()`是写在obj后面的，也就是obj调用的，所以this指向obj
2. obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；
3. foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；

```js
// 2 1 1
```

### 异步

Node 中的 process.nextTick 会先于其他 microtask 执行

```js

Promise.resolve().then(function() {
  console.log("promise1");
}); 
process.nextTick(() => {
console.log("nextTick");
});

// nextTick, promise1
```

#### 1
```js
const p1=new Promise((resolve, reject)=>{
  setTimeout(() => {
    resolve(1)
    throw new Error(2)
  }, 2000);
})
const p2 = p1.then(val=>{
  console.log(val);
  return val + 1
}).catch(err=>{
  console.log(err);
  return err
})
Promise.all([p2, Promise.reject(3).then(val2=>{
  console.log(val2);
})]).catch(err2=>{
  console.log(err2);
})

---
// 3
// Uncaught Error: 2
// 1
```

#### 2 !!!!
```js
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise1')
  })
}, 0)
const timer2 = setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)

// timer1
// promise1
// timer2
// promise2
```
```js
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');

---
start
promise1
timer1
promise2
timer2
```
??  每个setTimeout单独构成一次宏任务队列，而不是都加到任务队列一起处理
**每个settimeout之后执行自己的微任务**

#### 3
```js
setTimeout(() => {
  console.log(1);
}, 0);

new Promise(res => {
  res(console.log(3));
  console.log(4);
}).then(() => {
  console.log(5);
});

(async () => console.log(6))()
```

**resolve的参数如果是函数，会直接同步执行**

如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。
(即resolve中的参数相当于new Promise的代码，是同步的)
```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```
上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。


```js
3 4 6 5 1
```
### 原型

#### 1

```js
function Person(name) {
    this.name = name
}
var p2 = new Person('king');
console.log(p2.__proto__) //Person.prototype
console.log(p2.__proto__.__proto__) //Object.prototype
console.log(p2.__proto__.__proto__.__proto__) // null
console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
console.log(p2.constructor)//Person. 是p2.__proto__.constructor
console.log(p2.prototype)//undefined p2是实例，没有prototype属性
console.log(Person.constructor)//Function 一个空函数。 是Person.__proto__.constructor
console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性（它里面除了`__proto__`只有`constructor: ƒ Person(name)`）
console.log(Person.prototype.constructor)//Person
console.log(Person.prototype.__proto__)// Object.prototype
console.log(Person.__proto__) //Function.prototype
console.log(Function.prototype.__proto__)//Object.prototype
console.log(Function.__proto__)//Function.prototype
console.log(Object.__proto__)//Function.prototype
console.log(Object.prototype.__proto__)//null
```

>所有的函数（包括Function和Object）的`__proto__`都是Function.prototype

#### 2

```js {.line-numbers}
function Parent() {
    this.a = 1;
    this.b = [1, 2, this.a];
    this.c = { demo: 5 };
    this.show = function () {
        console.log(this.a , this.b , this.c.demo );
    }
}

function Child() {
    this.a = 2;
    this.change = function () {
        this.b.push(this.a);
        this.a = this.b.length;
        this.c.demo = this.a++;
    }
}

Child.prototype = new Parent();
var parent = new Parent();
var child1 = new Child();
var child2 = new Child();
child1.a = 11;
child2.a = 12;
parent.show();
child1.show();
child2.show();
child1.change();
child2.change();
parent.show();
child1.show();
child2.show();
```

涉及到的知识点很多，例如this的指向、原型、原型链、类的继承、数据类型等。

解析：
1. parent.show()，可以直接获得所需的值，没啥好说的；
   
2. child1.show()，Child的构造函数原本是指向Child的，题目显式将Child类的原型对象指向了Parent类的一个实例，需要注意Child.prototype指向的是Parent的实例parent，而不是指向Parent这个类。
   
3. child2.show()，这个也没啥好说的；
   
4. parent.show()，parent是一个Parent类的实例，Child.prorotype指向的是Parent类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响parent实例，所以输出结果不变；
   
5. child1.show()，child1执行了change()方法后，发生了怎样的变化呢?
   
- this.b.push(this.a)，由于this的动态指向特性，**this.b会指向Child.prototype上的b数组**,this.a会指向child1的a属性,所以Child.prototype.b变成了`[1,2,1,11]`;
  
- this.a = this.b.length，这条语句中this.a和this.b的指向与上一句一致，故结果为child1.a变为4;
  
- this.c.demo = this.a++，由于child1自身属性并没有c这个属性，所以此处的this.c会指向Child.prototype.c，this.a值为4，为原始类型，故赋值操作时会直接赋值，Child.prototype.c.demo的结果为4，而this.a随后自增为5(4 + 1 = 5)。
  
6. child2执行了change()方法, 而child2和child1均是Child类的实例，所以他们的原型链指向同一个原型对象Child.prototype,也就是同一个parent实例，所以child2.change()中所有影响到原型对象的语句都会影响child1的最终输出结果。
   
- this.b.push(this.a)，由于this的动态指向特性，this.b会指向Child.prototype上的b数组,this.a会指向child2的a属性,所以Child.prototype.b变成了`[1,2,1,11,12]`;
  
- this.a = this.b.length，这条语句中this.a和this.b的指向与上一句一致，故结果为child2.a变为5;
  
- this.c.demo = this.a++，由于child2自身属性并没有c这个属性，所以此处的this.c会指向Child.prototype.c，故执行结果为Child.prototype.c.demo的值变为child2.a的值5，而child2.a最终自增为6(5 + 1 = 6)。

>主要在于28行调用的，第13行的这个this.b，实际上这里的this还是指向这个child1，他只有一个a属性。但是this代表了这个child1，**找`.b`的属性的时候还是会顺着原型链找**，所以才找到了那个Parent实例的属性。

```js
parent.show(); // 1  [1,2,1] 5

child1.show(); // 11 [1,2,1] 5
child2.show(); // 12 [1,2,1] 5

parent.show(); // 1 [1,2,1] 5

child1.show(); // 5 [1,2,1,11,12] 5

child2.show(); // 6 [1,2,1,11,12] 5
```

#### 3
```js
Function.prototype.a = () => alert(1);

Object.prototype.b = () => alert(2);

function A() {};

var a = new A();

a.a();

a.b();

a instanceof A   
a instanceof Function
a instanceof Object
```

### 数组

#### 1

```js
let arr=[1,2,3]
let brr=arr.push(4)
let crr=arr.splice(1,1,)
console.log(arr)
console.log(brr)
console.log(crr)

---
[1, 3, 4]
4   //pusha返回的是数组长度，pop返回的是弹出的元素
[2]
```

splice的返回值
由被删除的元素组成的一个**数组**。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

#### 2 !!

```js
const objA = { a: 1 };
const objB = { b: 2 };
const arrA = [objA];
const arrB = [objB];

const v1 = arrA.concat(arrB);
const v2 = arrA.concat(...arrB);
const v3 = arrA.push(arrB); //[{ a: 1 }, [{ b: 2 }]]
const v4 = arrA.push(...arrB); //[{ a: 1 }, [{ b: 2 }], { b: 2 }]
console.log(v1);
console.log(v2);
console.log(v3);
console.log(v4);
```

**push返回的是数组长度!**

concat接受数组或一组值，如果是**数组则将数组拆开**，一组值则直接concat，**是浅拷贝**（类似于...）。

```js
[{ a: 1 }, { b: 2 }]
[{ a: 1 }, { b: 2 }]
2
3
```

### 其他

#### 1
```html {.line-numbers}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        .active{
            color: blue;
        }

        .line{
            font-size: 100px;
        }

    </style>
</head>
<body>
  
    <div id="example" >
        {{message}}
    </div>

    <script src="../js/vue.js"></script>
    <script>
        const vm = new Vue({
            el: '#example', //用于挂在要管理的元素
            data() {
                return {
                message: '123'
                }
            }
        })

    vm.message = 'hello world';
    console.log(vm.$el);
    console.log(vm.$el.innerText);
    console.log(vm.$el.innerText === 'hello world');
    </script>
</body>
</html> 
```

在异步更新执行之前操作 DOM 数据不会变化

原因：Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

所以如果你用一个for循环来动态改变数据100次，其实它只会应用最后一次改变，如果没有这种机制，DOM就要重绘100次，这固然是一个很大的开销。

nextTick触发的时机：
　
（1）同一事件循环中的代码执行完毕 -> （2）DOM 更新 -> （3）nextTick callback触发

解决办法：

```js
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'new message' // 更改数据
//使用 Vue.nextTick(callback) callback 将在 DOM 更新完成后被调用
Vue.nextTick(function () {
  vm.$el.textContent === 'new message' // true
  vm.$el.style.color = 'red' // 文字颜色变成红色
})
```

[见](D:\Coding\frontend\Vue01\01-Vue初体验\test.html)

>[Vue 数据更新了但页面没有更新的 7 种情况汇总及延伸总结](https://segmentfault.com/a/1190000022772025)
>[Vue 面试知识点总结【持续更新中～】](https://segmentfault.com/a/1190000019633325) 的 11、什么是$nextTick?


```html
<div id="example" > hello word </div>
123
false
``` 

#### 2
```js
var func1 = x => x
var func2 = x => {x}
var func3 = x => ({x})

func1(1)
func2(1)
func3(1)
```

注意这里func2的大括号被当成箭头函数函数体的括号了

```js
1 undefined {x:1}
```
