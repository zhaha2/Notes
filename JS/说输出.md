### 作用域
#### 1 ????
```js
var x=1,y=2;
var z=function() {
  var x= 2
  return {
    x: x,
    y: function(a,b) {
      x=a+b;
      // console.log("y");
      // console.log(x);
    },
    z: function() {
      // console.log("z");
      // console.log(x);
      return x;
    }
  }
};

a=z();
// console.log(a);
a.y(x,y);
// console.log(a);
console.log(x);
console.log(a.z(),a.x,x);

---
3 2 1
```

#### 2
```js
var a = 1;
function fn1() {
    function fn3() {
        var fn2 = function () {
            console.log(a);
        }
        fn2();
        a = 4;
    }
    var a = 2;
    return fn3;
}
var fn = fn1();
fn();   //2
```
```js
var a = 1;
function fn1() {
     function fn3() {
           var a = 4;
           fn2();
     }
     var a = 2;
     return fn3;
}
function fn2() {
 console.log(a);
}
var fn = fn1();
fn();   //1
```
作者：水桶侏儒猪😘
链接：https://www.nowcoder.com/discuss/612971?channel=-1&source_id=profile_follow_post_nctrack
来源：牛客网

考察的是函数作用域问题 这二个输出为1的，因为fn2所在为全局作用域，所以即使在内部调用，也是输出所在作用域的a，第一道题中，a=4没有用var来定义，则此时a自动提成为全局变量，所以此时输出的是fn3中的a =2

### 异步
#### 1
```js
const p1=new Promise((resolve, reject)=>{
  setTimeout(() => {
    resolve(1)
    throw new Error(2)
  }, 2000);
})
const p2 = p1.then(val=>{
  console.log(val);
  return val + 1
}).catch(err=>{
  console.log(err);
  return err
})
Promise.all([p2, Promise.reject(3).then(val2=>{
  console.log(val2);
})]).catch(err2=>{
  console.log(err2);
})

---
// 3
// Uncaught Error: 2
// 1
```

#### 2 !!!!
```js
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise1')
  })
}, 0)
const timer2 = setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)

// timer1
// promise1
// timer2
// promise2
```
```js
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');

---
start
promise1
timer1
promise2
timer2
```
??  每个setTimeout单独构成一次宏任务队列，而不是都加到任务队列一起处理
**每个settimeout之后执行自己的微任务**


### 数组
```js
let arr=[1,2,3]
let brr=arr.push(4)
let crr=arr.splice(1,1,)
console.log(arr)
console.log(brr)
console.log(crr)

---
[1, 3, 4]
4   //pusha返回的是数组长度，pop返回的是弹出的元素
[2]
```