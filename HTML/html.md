<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [1. iframe框架及优缺点](#1-iframe框架及优缺点)
- [2. src和href的区别](#2-src和href的区别)
- [3. HTML语义化](#3-html语义化)
  - [3.1 语义化好处](#31-语义化好处)
  - [3.2 注意语义化编写](#32-注意语义化编写)
  - [3.3 常见的语义化标签](#33-常见的语义化标签)
- [4. DOCTYPE(⽂档类型) 的作⽤](#4-doctype文档类型-的作用)
  - [4.1 为什么HTML5只需要写`<!DOCTYPE HTML>`](#41-为什么html5只需要写doctype-html)
- [5. script标签中defer和async的区别](#5-script标签中defer和async的区别)
  - [load 与 DOMContentLoaded 的区别](#load-与-domcontentloaded-的区别)
- [6. head标签](#6-head标签)
- [7. meta标签](#7-meta标签)
- [8. img的srcset属性](#8-img的srcset属性)
- [10. label](#10-label)
- [11. 浏览器乱码的原因是什么？如何解决](#11-浏览器乱码的原因是什么如何解决)
- [12. `<img>` 的 title 和 alt 属性的区别](#12-img-的-title-和-alt-属性的区别)
- [13. 懒加载](#13-懒加载)
- [常见标签](#常见标签)
- [前端优化](#前端优化)
  - [前端有哪些页面优化方法](#前端有哪些页面优化方法)
  - [前端SEO](#前端seo)
  - [单页应用的优缺点](#单页应用的优缺点)
  - [为什么说单页面的SEO不友好](#为什么说单页面的seo不友好)
  - [如何解决单页面SEO不友好的问题](#如何解决单页面seo不友好的问题)

<!-- /code_chunk_output -->

### 1. iframe框架及优缺点
iframe 元素会创建包含另外一个文档的内联框架（即**行内**框架，其实因为它有src属性，是替换元素）。

优点：
- 用来加载速度较慢的内容（如广告）
- 可以使脚本可以并行下载
- 可以实现跨子域通信

缺点：
- iframe 会阻塞主页面的 onload 事件
- 无法被一些搜索引擎索识别
- 会产生很多页面，不容易管理

>https://github.com/WindrunnerMax/EveryDay/blob/master/HTML/Iframe%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.md

### 2. src和href的区别
关键：src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。
1. src
src 是 source 的缩写，指向外部资源的位置，**指向的内容将会嵌入到文档中当前标签所在位置**；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。(src引用的外部资源不会阻塞渲染。)
  ` <script src =”js.js”></script> `

    >img的加载不会阻塞html的解析，但img加载后并不渲染，它需要**等待Render Tree生成完后**才和Render Tree一起渲染出来。未下载完的图片需等下载完后才渲染。、

1. href
href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，一般用于超链接. 如果在文档中添加 
  ` <link href=”common.css” rel=”stylesheet”/> `
那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。

### 3. HTML语义化
语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。
语义化可以总结为 **根据内容选择标签，用最恰当的标签来标记内容**。
例如网页中的标题使用`<h1>~<h6>`这样的标签，而不是使用`<div>+css`。

为什么要进行语义化？

1. 现在的开发基本上都是一个团队合作进行开发。这种情况下，我们写的代码不仅要让我们自己能看懂，而且也应该让别人也容易理解和阅读，要保证代码的可维护性，这一点很重要。但是在实际开发中，由于HTML的灵活性，以及CSS的强大，以至于实现同一种界面样式，不同的人写出来的代码可能实现方式都不太一样。实现糟糕的，可能全是div套div，这样的代码到时候维护的话可能就是一场灾难。这一点，个人觉得是最主要的因素。
2. 和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息
3. 考虑到代码的可复用性，可移植性，方便其他设备的解析执行。移动设备、盲人阅读器等。

---
#### 3.1 语义化好处
- **使HTML结构变得清晰**，有利于维护代码和添加样式。
- 通常语义化HTML会使代码变的更少，使页面加载更快。
即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构。
- **便于团队开发和维护，语义化更具可读性**，遵循W3C标准，可以减少差异化。
- **方便其他设备解析**（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页。
- **提升搜索引擎优化(SEO)的效果**。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫可以依赖于标签来确定上下文和各个关键字的权重。

#### 3.2 注意语义化编写
- 尽可能少的使用无语义的标签`<div>`和`<span>`。
- 不要使用纯样式标签，如`<b>`是纯样式标签，而`<strong>`的语义为加粗。
- 在`<lable>`标签中设置for来让说明文本和相对应的`<input>`关联起来。
- 表单域要用`<fieldset>`标签包起来，并用`<legend>`标签说明表单的用途。
- 需要强调的文本，可以包含在strong或者em标签中，`<strong>`默认样式是加粗，`<em>`是斜体。
- 使用表格时，标题要用`<caption>`，表头用`<thead>`，主体部分用`<tbody>`包围，尾部用`<tfoot>`包围。表头和一般单元格要区分开，表头用`<th>`，单元格用`<td>`。

#### 3.3 常见的语义化标签
``` html
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
---
上面是H5

<h1>~<h6> 定义页面的标题，<h1>-<h6>元素等级依次降低

<ul> 表示项目的无序列表，通常呈现为项目符号列表。
<ol> 表示项目的有序列表，通常呈现为编号列表。
<li> 表示列表中的项目。

<strong> 表示强调突出重点内容，浏览器通常以粗体显示内容。
<em> 标记强调重点的文本，可以嵌套<em>元素，嵌套的每个级别都表示强调程度更高。
```
本质上新语义标签与`<div>`、`<span>`没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成`<div class="nav">` 相当于`<nav>`。
### 4. DOCTYPE(⽂档类型) 的作⽤
DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的**是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。

浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是CSS1Compat）：
- CSS1Compat：标准模式(严格模式)（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
- BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的**向后兼容**的方式显示。
>见 https://github.com/WindrunnerMax/EveryDay/blob/master/HTML/DOCTYPE.md

---
文档声明的作用：文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。

`<!Doctype html>`的作用：`<!doctype html>` 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。

严格模式与混杂模式的区分：
- 严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码；
- 混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；

区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。
- 如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）；
- 包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）；
- DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；
- HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。

总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。

#### 4.1 为什么HTML5只需要写`<!DOCTYPE HTML>`
HTML5不基于SGML(标准通用标记语言)，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为。

### 5. script标签中defer和async的区别
如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。

下图可以直观的看出三者之间的区别:
![](image/2021-06-27-19-20-11.png)
其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。

defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：
- 执行顺序：
  - 多个带async属性的标签，不能保证加载的顺序(谁先下载完了谁加载)；
  - 多个带defer属性的标签，按照加载顺序执行(都在最后执行)；
- 脚本是否并行执行：
  - async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行。加载完成之后就执行，不保证什么时候执行；
  - defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，**DOMContentLoaded事件触发执行之前**。

---
- 都在页面 onload 之前执行
- 有 defer 属性的脚本会**阻止** DOMContentLoaded 事件，直到脚本被加载并且解析完成。

- async 属性的脚本无法确定是在 DOMContentLoaded 事件触发之前或之后执行。defer 属性的脚本在 DOMContentLoaded 事件触发之前执行。async 属性的脚本并不一定会按照顺序执行（先加载完成先执行），defer 属性的脚本会按照顺序执行。

#### load 与 DOMContentLoaded 的区别
load :
当**整个页面及所有依赖资源如样式表和图片都已完成加载时**，将触发load事件。
它与DOMContentLoaded不同，后者只要页面DOM加载完成就触发，无需等待依赖资源的加载。

DOMContentLoaded :
当**初始的 HTML 文档被完全加载和解析完成之后**，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。

>**注意**： DOMContentLoaded 事件必须等待其所属 script 之前的样式表加载解析完成才会触发。

>作者：听见下雨声
链接：https://juejin.cn/post/6869314860245745678

### 6. head标签
`<head>` 标签用于定义文档的头部，它是所有头部元素的容器。`<head>` 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。

文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。

下面这些标签可用在 head 部分：`<title>, <base>, <link>, <style>, <meta>, <script>, <noscript>, <command>`。 

其中 `<title>` 定义文档的标题，它是 head 部分中**唯一必需**的元素。

### 7. meta标签
meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些name作为大家使用的共识，开发者还可以自定义name。
提供给机器解读的一些元数据。页面搜索引擎优化，定义页面实用语言等等。

meta 元素定义的元数据的类型包括以下几种：
- 如果设置了 name 属性，meta 元素提供的是文档级别（document-level）的元数据，应用于整个页面。
- 如果设置了 http-equiv 属性，meta 元素则是编译指令，提供的信息与类似命名的HTTP头部相同。(属性定义了一个编译指示指令。这个属性叫做 http-equiv(alent) 是因为所有允许的值都是特定HTTP头部的名称)
- 如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。
- 如果设置了 itemprop 属性，meta 元素提供用户定义的元数据。

其中:
- http-equiv的值:
  >expires(过期时间)
  refresh(特定时间内自动刷新跳转)
  pragma(禁止浏览器从本地计算机缓存中访问页面内容no-cache)
  widows-target(设定页面在窗口中以独立页面展示，防止被当成frame页调用)
  set-cookie(自定义cooke)、
  ontent-Type(字符集)

- name的值:
  >keywords(关键字)
  description(主要内容)
  robots(none不被检索)
  author、generator(使用的制作软件)
  copyright
  viewport(适配移动端，可以控制视口的大小和比例)

### 8. img的srcset属性
响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：
```html
<img src="image-128.png" srcset="image-256.png 2x" />
```
使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。

按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：
```html
<img src="image-128.png"
     srcset="image-128.png 128w, image-256.png 256w, image-512.png 512w"
     sizes="(max-width: 360px) 340px, 128px" />
```
其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。

sizes语法如下：
```
sizes="[media query] [length], [media query] [length] ... "
```
sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。

---
为什么要用自适应的图片
1. 美术设计问题
这个网页在宽屏设备上表现良好，例如笔记本电脑或台式机。
然而，当你尝试在一个狭小的屏幕设备上查看本页面时，问题就会产生。网页的页眉看起来还可以，但是页眉这张图片占据了屏幕的一大部分的高度，在这个尺寸下，你很难看到在第一张图片内容里的人。
![](image/2021-06-28-19-19-26.png)
2. 分辨率切换问题
如果是在小屏手机屏幕上显示网页，那么没有必要在网页上嵌入这样大的图片。
位图有固定数量的像素宽，固定数量的像素高，与 矢量图 外观相同，但本质不同。如果显示尺寸大于原始尺寸，一张自身较小的位图看起来会有颗粒感（矢量图则不会）。
相反，没有必要在比图片实际尺寸小的屏幕上显示一张大图，这样做会浪费带宽——当可以在设备上使用小图像时，手机用户尤其不愿意因为下载用于桌面的大图像而浪费带宽。理想的情况是当访问网站时依靠不同的设备来提供不同的分辨率图片和不同尺寸的图片。
让事情变得复杂的是，有些设备有很高的分辨率，为了显示的更出色，可能需要超出你预料的更大的图像。这从本质上是一样的问题，但在环境上有一些不同。

```html
    <img srcset="elva-fairy-320w.jpg 320w,
             elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w"
     sizes="(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px"
     src="elva-fairy-800w.jpg" alt="Elva dressed as a fairy">
```
所以，有了这些属性，浏览器会：
- 查看设备宽度
- 检查sizes列表中哪个媒体条件是第一个为真
- 查看给予该媒体查询的槽大小
- 加载srcset列表中引用的最接近所选的槽大小的图像
>https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images#%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%9B%BE%E7%89%87

### 10. label 
label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。

- 使用方法1：
  ```html
  <div class="preference">
      <label for="cheese">Do you like cheese?</label>
      <input type="checkbox" name="cheese" id="cheese">
  </div>
  ```
- 使用方法2：可以将 `<input> `直接放在 `<label>` 里，此时则不需要 for 和 id 属性，因为关联已隐含存在：
  ```html
  <label>Do you like peas?
    <input type="checkbox" name="peas">
  </label>
  ```

其他使用事项：
- 关联标签的表单控件称为这个标签的已关联标签的控件。一个 input 可以与多个标签相关联。
- 点击或者轻触（tap）与表单控件相关联的 <label> 也可以触发关联控件的 click 事件。

### 11. 浏览器乱码的原因是什么？如何解决
产生乱码的原因：
- 网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；
- html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；
- 浏览器不能自动检测网页编码，造成网页乱码。

解决办法：
- 使用软件编辑HTML网页内容；
- 如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码；
- 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。

### 12. `<img>` 的 title 和 alt 属性的区别
- **alt** 属性，是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示或读屏器阅读图片（帮助盲人了解图片内容）。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。
作用是当无法显示文档中的图片时，可以为浏览者提供文字说明，是**用来替代图片的**，而不是提供额外说明文字的
如果图片可以正常顯示，則 img alt 就不會有任何的功能。

- **title** 属性是global attribute之一，作用是提供建议性的信息，通常是鼠标滑动到元素上是显示。
title属性可以用在除了base，basefont，head，html，meta，param，script和title之外的所有标签。
title属性可以为链接添加**描述性文字**，来更加清楚的表达链接的目的。

### 13. 懒加载
>https://zhuanlan.zhihu.com/p/25455672 图片懒加载的三种方式
https://segmentfault.com/a/1190000017795499
https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-loading 用loading: lazy属性

### 常见标签
https://www.cnblogs.com/progor/p/8444968.html

### 前端优化

#### 前端有哪些页面优化方法

减小资源（静态资源，后端加载的数据）大小
- 压缩代码HTML/CSS/JS( UglifyJS)
- 压缩图片、音视频大小
- Tree-Sharking 消除无用代码(通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。)
  
以上webpack都可以搞定

>此外 Gzip
从HTTP / 1.1开始，客户端可以通过使用HTTP请求中的Accept-Encoding: gzip, deflate来指示对压缩的支持。如果服务器在请求中看到此标头，则可以使用客户端列出的方法之一压缩响应，服务器通过响应中的Content-Encoding: gzip通知客户端采用gzip压缩。

>图片格式
[前端性能优化——图片篇](https://juejin.cn/post/6965761736083243044#heading-15)

避免同一时间的过多次数请求
- CSS 实现雪碧图
  >不同的图标元素都会将 background-url 设置为合并后的雪碧图的 uri；
不同的图标通过设置对应的 background-position 来展示大图中对应的图标部分。
- 图片懒加载：监听滚动后offsetTop,  使用src 替换 src（真实路径）
- 内联 base64 图片
  >当浏览器解析到这个的图片 url 时，就不会去请求并下载图片，直接解析 base64 字符串即可。
  但是这种方式的一个缺点在于相同的图片，相比使用二进制，变成 base64 后体积会增大 33%。
- 列表懒加载（分批加载）：监听滚动后offsetTop， 发送请求加载下一页的数据
- 路由懒加载
- 代码分包分块加载（webpack）
- 预加载技术
- 小程序分包、预下载等。
 
利用缓存（空间换时间）
- CDN 内容分发：获取更近网络节点缓存下来的静态资源
- 浏览器缓存（http缓存 自带）
- 部分资源保存在LocalStorage、sessionStorage、indexedDB或者APP缓存中（手动操作）
  
其他
- SSR 服务端渲染：解决SPA框架带来JS动态渲染页面带来的延迟和白屏问题。
- 骨架屏：减少白屏降低的用户体验。

页面解析
- 注意资源在页面文档中的位置(JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。)
-  使用 defer 和 async
-  慎用 @import(会把请求变得串行化)

>作者：天要
链接：https://www.zhihu.com/question/458055934/answer/1954186301

>[前端性能优化之旅](https://alienzhou.com/projects/fe-performance-journey/#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%88%EF%BC%9F)
https://github.com/WindrunnerMax/EveryDay/blob/master/HTML/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88.md

#### 前端SEO
>作者：不拿offer不放弃_
链接：https://www.nowcoder.com/discuss/412972?channel=-1&source_id=profile_follow_post_nctrack

- 合理的title，description，keywords：搜索对着三项的权重逐渐减小，title值强调重点即可，重要关键词出现不要超过两次，而且要靠前。description把页面的内容高度概括，长度合适，不可过分堆砌关键词，不同页面的description有所不同。keywords列举出重要关键词即可。

- 语义化的html代码，让搜索引擎容易理解网页。

- 重要内容html代码放在最前面，因为搜索引擎抓取html顺序是从上至下的，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取。

- 重要内容不要用js输出，因为爬虫不会执行js获取内容。
  
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标。

- 少用iframe，搜索引擎不会抓取iframe中的内容

- 非装饰性图片必须加alt。

#### 单页应用的优缺点

优点

- 有良好的交互体验。能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载。
单页面是一次性把web应用的所有代码（HTML，JavaScript和CSS）全部请求过来，有时候考虑到首屏加载太慢会按需加载。这样一来，以后用户的每一个动作都不会重新加载页面（即不用再问服务器要页面的HTML慢，css和js代码），取而代之的是利用 JavaScript **动态的变换HTML的内容**（这不需要和服务器交互，除非数据是动态，那么只需要问服务器要数据（ajax）即可）。

- 减轻服务器压力。服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；


缺点

- SEO难度较高。SEO差的原因是因为页面中的内容都是靠js渲染出来了，在百度或者goole这样的搜素引擎当中，排名会比较差。

- 首屏加载(初次加载)耗时多。为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；

>作者：HMGDCR598
链接：https://juejin.cn/post/6913436819115737102

#### 为什么说单页面的SEO不友好
因为单页面的情况下的页面中的很多内容都是根据匹配到的路由**动态生成并展示出来**的,而且很多页面内容是**通过ajax异步获取**的,网络抓取工具并不会等待异步请求完成后再行抓取页面内容,对于网络抓取工来说去准确模拟相关的行为获取复合数据是很困难的,它们更擅长对静态资源的抓取和分析。

#### 如何解决单页面SEO不友好的问题
明白了问题出在哪里,“搜索引擎蜘蛛”或“网络爬虫”程序更擅长对**静态资源**的抓取和更新,那我们就要采取相应策略生成尽可能多的静态资源,来让网络爬虫获取更多的数据,从而提升网站的搜索排名.目前市面上用的比较多的就是以下两种策略: 预渲染和SSR(服务端渲染).

**预渲染**
预渲染指的是打包生成一些主要路由对应的静态html文件,这样有了更多的静态资源,网络爬虫可以抓取到更多的网站信息,提升网站的搜索排名.

**SSR(服务端渲染)**
服务端渲染就是先向后端服务器请求数据,然后生成完整首屏html返回给浏览器, 服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML,网络爬虫可以抓取到完整的页面信息,SSR另一个很大的作用是加速首屏渲染,因为无需等待所有的JavaScript都完成下载并执行,才显示服务端渲染的标记,所以用户会更快地看到完整渲染的页面.

---
客户端渲染
前端做视图和交互，后端只提供接口数据，前端通过ajax向服务端请求数据，获取到数据后通过js生成DOM插入HTML页面，最终渲染给用户。页面代码在浏览器源代码中看不到

客户端渲染优点：
- 使得服务器计算压力变轻
- 做到了前后端分离，在团队开发中只要负责各自的任务即可，使开发效率有明显提升。
  
客户端渲染缺点：
- 不利于SEO、搜索引擎爬虫看不到完整的程序源码
- 请求增多时用户等待时间变长，导致首屏渲染慢
- 消耗的是用户浏览器的性能

---
服务端渲染

服务端在返回html之前，在特定的区域，符号里用数据填充生成html，再发送给客户端html，客户端解析html最终渲染出页面给用户，页面代码在浏览器源代码中看得到。

服务端渲染优点：
- 响应快，用户体验好，首屏渲染快
- 对搜索引擎友好，搜索引擎爬虫可以看到完整的程序源码，有利于SEO

服务端渲染缺点：
- 增加了服务器的计算压力，消耗服务器性能
- 不容易维护，如果不使用node中间层，前后端分工不明，不能进行良好的并行开发

---
两种渲染对比

本质上两种渲染都是一样的，都是进行的字符串拼接生成html,两者的差别最终体现在时间消耗以及性能消耗上。

客户端在不同网络环境下进行数据请求，客户端需要经历从js加载完成到数据请求再到页面渲染这个时间段。导致了大量时间的消耗以及浏览器性能的消耗。
而服务端在内网请求，数据响应快，不需要等待js代码加载，可以先请求数据再渲染可视部分然后返回给客户端，客户端再做二次渲染,这样大部分消耗的是服务端的性能。客户端页面响应时间也更快。