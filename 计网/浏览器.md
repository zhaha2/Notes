### 1. 浏览器缓存
https://juejin.cn/post/6844903763665240072
https://github.com/WindrunnerMax/EveryDay/blob/master/Browser/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.md 看他的参考

前端缓存：
![](image/2021-07-07-16-19-22.png)
https://www.jianshu.com/p/227cee9c8d15
### 2. css和js阻塞页面渲染
理论上，**既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们**。
css不阻塞DOM解析，会阻塞页面渲染
https://juejin.cn/post/6844903497599549453

### 3. 跨域
http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html
https://www.ruanyifeng.com/blog/2016/04/cors.html

jsonp cors 反向代理

同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。

同源政策主要限制了三个方面：
- 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
- 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
- 当前域下 ajax 无法发送跨域请求。

同源政策的目的主要是为了**保证用户的信息安全**，防止恶意的网站窃取数据。它只是**对 js 脚本的一种限制**，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

>一定要注意跨域是**浏览器的限制**，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。

### 4. 浏览器进程
https://github.com/amandakelake/blog/issues/55

[浏览器进程架构的演化](https://juejin.cn/post/6844904019131891725#heading-6)
#### 为什么要给浏览器使用多进程架构？
因此Chrome一开始就设计为把隔离性作为基本的设计原则，用进程的隔离性来实现对App的隔离。这样用户就不用担心：

一个Web App挂掉造成其他所有的Web App全部挂掉（稳定性）
一个Web App可以以某种形式访问其他App的数据（安全性）

以及Web App之间是并发的，可以提供更好的响应，一个App的渲染卡顿不会影响其他App的渲染（性能）（当然这点线程也能做到）

### 渲染过程
真实`DOM`和其解析流程

本节我们主要介绍真实   `DOM` 的解析过程，通过介绍其解析过程以及存在的问题，从而引出为什么需要虚拟`DOM`。一图胜千言，如下图为 `webkit` 渲染引擎工作流程图

![1.png](https://github.com/fengshi123/blog/blob/master/assets/virtual_dom/1.png?raw=true)

所有的浏览器渲染引擎工作流程大致分为5步：创建        `   DOM` 树 —> 创建 `Style Rules` -> 构建 `Render` 树 —> 布局 `Layout` -—> 绘制 `Painting`。

- 第一步，构建 `DOM` 树：用 `HTML` 分析器，分析 `HTML` 元素，构建一棵 `DOM` 树；

- 第二步，生成样式表：用 `CSS` 分析器，分析 `CSS` 文件和元素上的 `inline` 样式，生成页面的样式表；

- 第三步，构建 `Render` 树：将 `DOM` 树和样式表关联起来，构建一棵 `Render` 树（`Attachment`）。每个 `DOM` 节点都有 `attach` 方法，接受样式信息，返回一个 `render` 对象（又名 `renderer`），这些 `render` 对象最终会被构建成一棵 `Render` 树；

- 第四步，确定节点坐标：根据 `Render` 树结构，为每个 `Render` 树上的节点确定一个在显示屏上出现的精确坐标；

- 第五步，绘制页面：根据 `Render` 树和节点显示坐标，然后调用每个节点的 `paint` 方法，将它们绘制出来。

### XSS 和 CSRF
[浅说 XSS 和 CSRF](https://github.com/dwqs/blog/issues/68)
[Web安全之CSRF实例解析 ](https://github.com/funnycoderstar/blog/issues/142)
https://www.yuque.com/cuggz/feplus/oewdt3

#### CSRF
注意，cookie是浏览器自动加到http头部发送的，token（通常存在localStorage中）不会，要显式的通过ajax脚本添加上才发送。所以CSRF攻击只能跳转链接，让浏览器自动带上cookie，但不能带上token。

[Cookie 的 SameSite 属性](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

[vue前端利用localStorage存储token值并放到请求头headers实例](https://blog.csdn.net/bentou_/article/details/105400022?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.base)