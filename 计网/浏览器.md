### 1. 浏览器缓存
https://juejin.cn/post/6844903763665240072
https://github.com/WindrunnerMax/EveryDay/blob/master/Browser/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.md 看他的参考

前端缓存：
![](image/2021-07-07-16-19-22.png)
https://www.jianshu.com/p/227cee9c8d15

#### If-None-Match
当与 If-None-Match 一同出现时，If-Modified-Since会被忽略掉，除非服务器不支持 If-None-Match。

### 2. css和js阻塞页面渲染
理论上，**既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们**。

#### css不阻塞DOM解析，会阻塞页面渲染


打开浏览器，可以看到是首先打印出div这个DOM节点，过3s左右之后才渲染出一个浅蓝色的div。这就证明了CSS 是不会阻塞 DOM 的解析的，尽管CSS下载需要3s，但这个过程中，浏览器不会傻等着CSS下载完，而是会解析DOM的。

浏览器是解析DOM生成DOM Tree，结合CSS生成的CSS Tree，最终组成render tree，再渲染页面。由此可见，在此过程中CSS完全无法影响DOM Tree，因而无需阻塞DOM解析。然而，DOM Tree和CSS Tree会组合成render tree，那CSS会不会页面阻塞渲染呢？

其实这一点，刚才的例子已经说明了，如果CSS 不会阻塞页面阻塞渲染，那么CSS文件下载之前，浏览器就会渲染出一个浅绿色的div，之后再变成浅蓝色。浏览器的这个策略其实很明智的，想象一下，如果没有这个策略，页面首先会呈现出一个原始的模样，待CSS下载完之后又突然变了一个模样。用户体验可谓极差，而且渲染是有成本的。

因此，基于性能与用户体验的考虑，浏览器会尽量减少渲染的次数，CSS顺理成章地阻塞页面渲染。

---

#### JS阻塞DOM解析和渲染


对此的优化其实也很显而易见，具体分为两类。
- 如果JS文件体积太大，同时你确定没必要阻塞DOM解析的话，不妨按需要**加上defer或者async**属性，此时脚本下载的过程中是不会阻塞DOM解析的。
- 而如果是文件执行时间太长，不妨分拆一下代码，不用立即执行的代码，可以使用一下以前的黑科技：setTimeout()。当然，现代的浏览器很聪明，它会“偷看”之后的DOM内容，碰到如`<link>、<script>`和`<img>`等标签时，它会帮助我们先行下载里面的资源，不会傻等到解析到那里时才下载。

浏览器遇到` <script> `标签时，会触发页面渲染
其实**这才是**解释上面为何JS执行会等待CSS下载的原因。

每次碰到`<script>`标签时，浏览器都会渲染一次页面。这是基于同样的理由，浏览器不知道脚本的内容，因而碰到脚本时，只好先渲染页面，确保脚本能获取到最新的DOM元素信息，尽管脚本可能不需要这些信息

---
综上所述，我们得出这样的**结论**：

- CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。
- JS 阻塞 DOM 解析，但浏览器会"偷看"DOM，预先下载相关资源。
- 浏览器遇到 `<script>`且没有defer或async属性的 标签时，会触发页面渲染，因而**如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本**。

- css 文件没下载并解析完成之前，后续的 js 脚本不能执行。
- css 文件的下载不会阻塞前面的 js 脚本执行。

>看 [原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的](https://juejin.cn/post/6844903497599549453)

### 3. 跨域

#### 同源
http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html

##### 目的
同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？

很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。

由此可见，"同源政策"是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。

##### 限制范围
随着互联网的发展，"同源政策"越来越严格。目前，如果非同源，共有三种行为受到限制。

（1） Cookie、LocalStorage 和 IndexDB 无法读取。

（2） DOM 无法获得。

（3） AJAX 请求不能发送。

虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。

#### 跨域

https://www.ruanyifeng.com/blog/2016/04/cors.html

jsonp cors 反向代理

---

而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样

举个例子：假如一个域名为aaa.cn的网站，它发起一个资源路径为 aaa.cn/books/getBookInfo 的 Ajax 请求，那么这个请求是同域的，因为资源路径的协议、域名以及端口号与当前域一致（例子中协议名默认为http，端口号默认为80）。但是，如果发起一个资源路径为 bbb.com/pay/purchase 的 Ajax 请求，那么这个请求就是跨域请求，因为域不一致，与此同时由于安全问题，这种请求会受到同源策略限制。

---
同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。

同源政策主要限制了三个方面：
- 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
- 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
- 当前域下 ajax 无法发送跨域请求。

同源政策的目的主要是为了**保证用户的信息安全**，防止恶意的网站窃取数据。它只是**对 js 脚本的一种限制**，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

>一定要注意跨域是**浏览器的限制**，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。

> 稍后 nginx跨域配置 https://segmentfault.com/a/1190000015597029

### 4. 浏览器进程
https://github.com/amandakelake/blog/issues/55

[浏览器进程架构的演化](https://juejin.cn/post/6844904019131891725#heading-6)
#### 为什么要给浏览器使用多进程架构？
因此Chrome一开始就设计为把隔离性作为基本的设计原则，用进程的隔离性来实现对App的隔离。这样用户就不用担心：

一个Web App挂掉造成其他所有的Web App全部挂掉（稳定性）
一个Web App可以以某种形式访问其他App的数据（安全性）

以及Web App之间是并发的，可以提供更好的响应，一个App的渲染卡顿不会影响其他App的渲染（性能）（当然这点线程也能做到）

### 渲染过程
真实`DOM`和其解析流程

本节我们主要介绍真实   `DOM` 的解析过程，通过介绍其解析过程以及存在的问题，从而引出为什么需要虚拟`DOM`。一图胜千言，如下图为 `webkit` 渲染引擎工作流程图

![1.png](https://github.com/fengshi123/blog/blob/master/assets/virtual_dom/1.png?raw=true)

所有的浏览器渲染引擎工作流程大致分为5步：创建        `   DOM` 树 —> 创建 `Style Rules` -> 构建 `Render` 树 —> 布局 `Layout` -—> 绘制 `Painting`。

- 第一步，构建 `DOM` 树：用 `HTML` 分析器，分析 `HTML` 元素，构建一棵 `DOM` 树；

- 第二步，生成样式表：用 `CSS` 分析器，分析 `CSS` 文件和元素上的 `inline` 样式，生成页面的样式表；

- 第三步，构建 `Render` 树：将 `DOM` 树和样式表关联起来，构建一棵 `Render` 树（`Attachment`）。每个 `DOM` 节点都有 `attach` 方法，接受样式信息，返回一个 `render` 对象（又名 `renderer`），这些 `render` 对象最终会被构建成一棵 `Render` 树；

- 第四步，确定节点坐标：根据 `Render` 树结构，为每个 `Render` 树上的节点确定一个在显示屏上出现的精确坐标；

- 第五步，绘制页面：根据 `Render` 树和节点显示坐标，然后调用每个节点的 `paint` 方法，将它们绘制出来。

### XSS 和 CSRF
[浅说 XSS 和 CSRF](https://github.com/dwqs/blog/issues/68)
[Web安全之CSRF实例解析 ](https://github.com/funnycoderstar/blog/issues/142)
https://www.yuque.com/cuggz/feplus/oewdt3

#### CSRF
注意，cookie是浏览器自动加到http头部发送的，token（通常存在localStorage中）不会，要显式的通过ajax脚本添加上才发送。所以CSRF攻击只能跳转链接，让浏览器自动带上cookie，但不能带上token。

#### 如何防御CSRF

##### 利用cookie的SameSite
SameSite有3个值： Strict, Lax和None
1. Strict。浏览器会完全禁止第三方cookie。比如 a.com的页面中访问 b.com的资源，那么a.com中的cookie不会被发送到 b.com服务器，只有从b.com的站点去请求b.com的资源，才会带上这些Cookie
2. Lax。相对宽松一些，在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get方式的表单这两种方式都会携带Cookie。但如果在第三方站点中**使用POST方法或者通过 img、Iframe等标签加载的URL，这些场景都不会携带Cookie**。
3. None。任何情况下都会发送 Cookie数据

我们可以根据实际情况将一些关键的Cookie设置 Stirct或者 Lax模式，这样在跨站点请求的时候，这些关键的Cookie就不会被发送到服务器，从而使得CSRF攻击失败。

---
有些情况下需要第三方cookie所以要设置SameSite：None

但是要注意：

- HTTP 接口不支持 SameSite=none
如果你想加 SameSite=none 属性，那么该 Cookie 就**必须同时加上 Secure 属性**，表示只有在 HTTPS 协议下该 Cookie 才会被发送。

- 需要 UA 检测，部分浏览器不能加 SameSite=none
IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性

##### 验证请求的来源点

由于CSRF攻击大多来自第三方站点，可以在服务器端验证请求来源的站点，禁止第三方站点的请求。
可以通过HTTP请求头中的 Referer和Origin属性。

![HTTP请求头](https://cdn.suisuijiang.com/ImageMessage/5adad39555703565e79040fa_1591260224629.png)

但是这种 **Referer和Origin**属性是可以被伪造的，碰上黑客高手，这种判断就是不安全的了。

##### CSRF Token
1. 最开始浏览器向服务器发起请求时，服务器生成一个CSRF Token。CSRF Token其实就是服务器生成的字符串，然后将该字符串种植到返回的页面中(可以通过Cookie)
2. 浏览器之后再发起请求的时候，需要带上页面中的 `CSRF Token`（在request中要带上之前获取到的Token，比如 `x-csrf-token：xxxx`）, 然后服务器会验证该Token是否合法。第三方网站发出去的请求是无法获取到 `CSRF Token`的值的。

[Cookie 的 SameSite 属性](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

[vue前端利用localStorage存储token值并放到请求头headers实例](https://blog.csdn.net/bentou_/article/details/105400022?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.base)