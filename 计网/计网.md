https://juejin.cn/post/6915362842212302862#heading-2 「计算机网络」前端必备知识，看到就是赚到系列（上）

https://mp.weixin.qq.com/s/iSZp41SRmh5b2bXIvzemIw  探究！一个数据包在网络中的心路历程

https://juejin.cn/post/6939691851746279437#heading-17 字节跳动最爱考的前端面试题：计算机网络基础

https://www.jianshu.com/p/3fc3646fad80 http的长连接和短连接（史上最通俗！）

https://blog.nowcoder.net/n/d5e2c1b0abf1416e8379c0c24eb3458a 前端复习企划7-网络
### 1. 网络模型
<!-- https://www.yuque.com/cuggz/interview/cdpgm0#NQHWi -->

https://www.yuque.com/cuggz/interview/cdpgm0#YhF2j

https://blog.nowcoder.net/n/d5e2c1b0abf1416e8379c0c24eb3458a

https://juejin.cn/post/6915362842212302862

![](image/2021-06-28-20-46-38.png)

![](image/2021-06-30-16-57-59.png)

---

应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。

表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。

会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。

运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：

- TCP：提供面向连接的、可靠的数据传输服务；

- UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。

网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。

数据链路层：数据链路层通常简称为链路层。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。

物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。

>作者：程序员库森
链接：https://www.nowcoder.com/discuss/694989?channel=-1&source_id=profile_follow_post_nctrack

### 2. tcp udp
https://www.cnblogs.com/xiaolincoding/p/12732052.html 30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制

https://www.cnblogs.com/xiaolincoding/p/12638546.html 被问千百遍的 TCP 三次握手和四次挥手面试题

#### TCP连接怎么断开

有的时候，服务器需要知道客户端主机是否已崩溃并且关闭，或者崩溃但重启。许多实现提供了存活定时器来完成这个任务。

TCP的保活定时器能够保证TCP连接一直保持，但是TCP的保活定时器不是每个TCP/IP协议栈就实现了，因为RFC并不要求TCP保活定时器一定要实现。

---
很多人都知道TCP并不会去主动检测连接的丢失，这意味着，如果双方不产生交互，那么如果网络断了或者有一方机器崩溃，另外一方将永远不知道连接已经不可用了。检测连接是否丢失的方法大致有两种：keepalive和heart-beat。

Keepalive是很多的TCP实现提供的一种机制，它允许连接在空闲的时候双方会发送一些特殊的数据段，并通过响应与否来判断连接是否还存活着（所谓keep~~alive）。我曾经写过一篇关于keepalive的blog ，但后来我也发现，其实keepalive在实际的应用中并不常见。为何如此？这得归结于keepalive设计的初衷。**Keepalive适用于清除死亡时间比较长的连接**。
比如这样的场景：一个用户创建tcp连接访问了一个web服务器，当用户完成他执行的操作后，很粗暴的直接拨了网线。这种情况下，这个tcp连接已经断开了，但是web服务器并不知道，它会依然守护着这个连接。如果web server设置了keepalive，那么它就能够在用户断开网线的大概几个小时以后，确认这个连接已经中断，然后丢弃此连接，回收资源。
采用keepalive，它会先要求此连接一定时间没有活动（一般是几个小时），然后发出数据段，经过多次尝试后（每次尝试之间也有时间间隔），如果仍没有响应，则判断连接中断。可想而知，整个周期需要很长的时间。
所以，如前面的场景那样，需要一种方法能够清除和回收那些在系统不知情的情况下死去了很久的连接，keepalive是非常好的选择。

但是，在大部分情况下，特别是分布式环境中，我们需要的是一个能够快速或者实时监控连接状态的机制，这里，heart-beat才是更加合适的方案。
Heart-beat（心跳），按我的理解，它的原理和keepalive非常类似，都是发送一个信号给对方，如果多次发送都没有响应的话，则判断连接中断。它们的不同点在于，keepalive是tcp实现中内建的机制，是在创建tcp连接时通过设置参数启动keepalive机制；而heart-beat则需要在tcp之上的应用层实现。一个简单的heart-beat实现一般测试连接是否中断采用的时间间隔都比较短，可以很快的决定连接是否中断。并且，由于是在应用层实现，因为可以自行决定当判断连接中断后应该采取的行为，而keepalive在判断连接失败后只会将连接丢弃。
关于heart-beat，一个非常有趣的问题是，应该在传输真正数据的连接中发送心跳信号，还是可以专门创建一个发送“心跳”信号的连接。比如说，A，B两台机器之间通过连接m来传输数据，现在为了能够检测A，B之间的连接状态，我们是应该在连接m中传输心跳信号，还是创建新的连接n来专门传输心跳呢？我个人认为两者皆可。如果担心的是端到端的连接状态，那么就直接在该条连接中实现心跳。但很多时候，关注的是网络状况和两台主机间的连接状态，这种情况下， 创建专门的心跳连接也未尝不可。

>[tcp 服务端如何判断客户端断开连接](https://www.cnblogs.com/youxin/p/4056041.html)

#### keep-alive

TCP 的 Keepalive 这东西其实就是 TCP 的**保活机制**

[TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？](https://mp.weixin.qq.com/s/25atTs4b-vORIx525ur_aw)

### 3. 键⼊⽹址到⽹⻚显示，期间发⽣了什么
小林coding 5.1
https://blog.nowcoder.net/n/d5e2c1b0abf1416e8379c0c24eb3458a
https://juejin.cn/post/6902032954034225159#heading-7 加入了浏览器进程相关的过程
>注：域名解析过程就是DNS过程

### 4. HTTPS
对称加密
有点：快捷
缺点：需要维护密钥

非对称加密
优点：不用维护密钥
缺点：慢（要大素数计算）

为什么用混合加密，每次生成新的密钥：省的服务器保存和维护用户的对称密钥

### 4. 进程线程
小林coding 系统
>看 
[一文读懂什么是进程、线程、协程（建议收藏）](http://www.360doc.cn/article/32196507_906628857.html)

---
可以从四方面思考：
1.1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。
1.2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。
1.3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间。
1.4. 调度和切换：线程上下文切换比进程上下文切换要快得多。


### 5. CDN
http://hpoenixf.com/DNS%E4%B8%8ECDN%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB.html
https://juejin.cn/post/6844903906296725518#heading-2 漫话：如何给女朋友解释什么是CDN？
https://juejin.cn/post/6844904190913822727

最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：

- 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。

- CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户

- 用户向CDN的全局负载均衡设备发起内容URL访问请求

- CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求

- 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址

- 全局负载均衡设备把服务器的IP地址返回给用户

- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地

>作者：Jieunsi
链接：https://www.nowcoder.com/discuss/670720?type=0&order=0&pos=13&page=1&ncTraceId=&channel=-1&source_id=discuss_tag_nctrack

**回源**
CDN节点未缓存资源或者缓存资源已到期时，节点会回源站获取资源，返回给客户端。

#### 假设同样的资源，我用域名去访问，访问到哪个服务器取决于什么？

DNS

### http

#### get和post
先说相同点，只有了解了相同点之后才能理解为什么会发生混淆。两者都能向服务器发送数据，提交的“内容”[注1]的格式相同，都是var_1=value_1&var_2=value_2&....get 和 post 区别如字面，一个是get（获取），一个是post（发送）。get用来告诉服务器需要获取哪些内容（uri+query），向静态页面（uri）请求则直接返回文件内容给浏览器，向一个动态页面**请求时可以提供查询参数（query）以获得相应内容**。post用来向服务器提交内容，**主要是为了提交**，而不是为了请求内容，就是说post的初衷并不要求服务器返回内容[注2]，只是提交内容让服务器处理（主要是存储或者处理之后再存储）。get和post出现混淆是因为对提交的数据处理方法的滥用造成的，数据是无辜的。

混淆之一：  将get提交的用来查询的字段当作是存储数据存入了服务器端文件或者数据库。然后就误以为get是用来提交用于存储的数据的。

混淆之二：  编写脚本在服务器端通过处理post提交的数据并返回内容。只要有数据，就能用来进行判断，脚本怎写是程序员的事，而不在乎数据来源的形式（post、get，或者是自己预设值的常量）。这点功能上确实没问题，只是背离的其初始目的而已。

由于都是要传送数据，且数据格式相同（即使数据格式不同，只要能提取出相应数据）。使用的时候难免出现张冠李戴，将get数据用来存储、将post数据用来检索返回数据。但是二者还是有区别的（主要是根据其用途而“人为”[注3]造成的），get的长度限制在2048字节（由浏览器和服务器限制的，这是目前IE的数据，曾经是1024字节），很大程度上限制了get用来传递“存储数据”的数据的能力，所以还是老老实实用来做检索吧；post则无此限制（只是HTTP协议规范没有进行大小限制，但受限于服务器的处理能力），因此对于大的数据（一般来说需要存储的数据可能会比较大，比2048字节大）的传递有天然的优势，谁让它是 nature born post 呢。

get提交的数据是放在url里，目的是灵活的向服务其提交检索请求，可以在地址栏随时修改数据以变更需要获取的内容，比如直接修改分页的编号就跳到另外一个分页了（当然也可能是 404）。post提交的数据放在http请求的正文里，目的在于提交数据并用于服务器端的存储，而不允许用户过多的更改相应数据（主要是相对于在url 修改要麻烦很多，url的修改只要点击地址栏输入字符就可以了），除非是专门跑来编辑数据的。

且get可以缓存。

花边：post和get的安全性在传输的层面上区别不大，但是采用url提交数据的get方式容易被人肉眼看到，或者出现在历史纪录里，还是可能被肉眼看到，都是一些本地的问题。

注1：我强调的是内容，至于http协议中的get和post的格式大家有兴趣就自己看看吧。

注2：get方式主要是为了获得预期内容，即uri+query相同时所得到的内容应该是相同的。而post主要是提交内容，至于是否有必要返回页面可能只是出于用户体验，比如注册时返回你的注册id，但是如果只是返回一个“您已注册成功”的相同页面（即使你post的数据不一样）也没什么好奇怪的。

注3：关于这个“人为”，不是那么贴切，get和post还是有技术层面的区别的。但是从表象上看暂且这么说吧，毕竟二者的混淆也是“人为”的。

---
GET是安全的、幂等的，而POST是 不安全的、不幂等的。
GET在浏览器回退或者刷新时是无害的，而POST会再次提交数据请求。
GET产生的URL地址可以作为书签保存，而POST不行。
GET请求会被浏览器主动cache，而POST不会主动缓存。(这里缓存就是http缓存)
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数长度受URL长度限制，而POST的大小取决于后端配置。
GET参数只接受ASCII字符的数据类型，而POST没有限制，可以传输二进制数据。
GET比POST更不安全，因为参数直接暴露在URL上，所以不适合传递敏感信息。
GET参数通过URL传递，直接可见，POST的参数放在Request body中，不直接可见。

#### post和put
POST方法和PUT方法请求最根本的区别是发起请求的目的不同。post 请求的目的是根据资源自身的语义来处理这个资源（译注：我理解这个意思就是说，post请求可以根据实际请求的资源来决定到底怎么处理，原文中4.3.3节给了一些例子。我会把我的翻译版附在本文末尾。）。put请求的目的是用来替换整个目标资源。**put 请求具有 幂等性**（idempotent）。（幂等性的意思在这个RFC的4.2.2里说了“同样的请求，不管发多少次，每次服务器处理完之后的结果，都和只发一次是一样的。”这里我举个例子帮助大家理解：你的服务器端存放了一个文章收藏夹，你通过一个put请求来修改收藏夹里的文章名字，这个 put 请求的请求体里包含了整个文章收藏夹里所有文章的名字。当服务端处理这个请求时，只要从 put 请求里拿出这个文章名字列表，整个存到服务器上，就是一个完整的新的收藏夹。那么这样的put 请求，无论你是发一次，还是发多次，假设服务器都能成功处理，那么最终对服务器造成的影响都是一样的：即服务器端原有的收藏夹里的文章列表被替换成了put请求里带的收藏夹的文章列表。）

1. 服务端在处理时post方法发出的请求时，应该按照请求的具体资源的具体语义来对该资源做相应的处理。例如，以下情况一般使用 Post 方法：

        提供一整块数据时，比如，向html表单的文本框里输入数据，然后把整个表单提交，来对这些数据做处理。
        在论坛、群组、邮件列表、博客或者类似的东西里发表文章时。
        想要通过请求在服务器端创建一个新资源时。
        像服务端的一个资源里插入一些数据时。

2. put方法用于创建或者替换整个资源，请求体（body）里包含这个资源的完整描述。一个 put 请求如果成功了，那么理论上来说，对同样的 url 做一个 get 请求，应该能得到一个 200 (OK) 的响应。但实际上，并不能保证get 到200的响应。因为，可能同时有其他人也在对这个资源做操作，那么就可能在get请求抵达服务器之前，这个资源已经被别人改掉了。所以说， put 请求成功，只能代表在这个请求被服务器处理的那个时刻上，这个资源被创建或替换成请求体里的样子了。（译注：比如我用put请求修改一个小组里的所有用户列表，我的请求体里包含了小组里所有用户的用户名列表，那么在服务器处理我这个请求，并告诉我成功了的那个时刻，这个小组的用户名一定和我发的put请求里的用户名列表是一样的。但是同时有可能有别的人也在尝试改这个小组的信息，那么我紧接着发一个 get 请求，可能get到的小组里的用户名列表跟我刚才put的已经不一样了。）

---
当需要以更新的形式来修改某一具体资源的时候，如何判断用PUT还是POST呢？

很简单，如果该更新对应的URI多次调用的结果一致，则PUT

比如更新某个blog文章，因为该文章具有单一的具体URI，所以每次更新提交相同的内容，结果都一致

/blog/{document_id}/update

在每次更新提交相同的内容，最终的结果不一致的时候，用POST

举个很常见的例子，一个接口的功能是将当前余额减一个值，每次提交指定该值为100，接口如下

/amount/deduction

调用一次，你的余额-100，调用两次，余额-200

这个时候就用POST

#### http请求头以及响应头
[关于常用的http请求头以及响应头详解](https://juejin.cn/post/6844903745004765198)

#### 一个 tcp 连接能发几个 http 请求

- HTTP/1.0 :一个tcp连接只能发一个http请求。每次服务端返回响应后TCP连接会断开。
- HTTP/1.1: 默认开启Connection: keep-alive，一个TCP连接可以发多个http请求，但是多个请求是串行执行。（注意区别TCP的keep-alive）
- HTTP/2: 引入了多路复用技术 和二进制分帧，同个域名下的请求只需要占用一个 TCP 连接，请求和响应是并行执行。(详细请看：[https://developer.51cto.com/art/201910/604255.htm])

#### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制

假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受（串行），但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。

所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。
​
那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能**用 HTTP2**，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上**建立多个 TCP 连接**，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。

>https://zhuanlan.zhihu.com/p/61423830