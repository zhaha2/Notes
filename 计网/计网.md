https://juejin.cn/post/6915362842212302862#heading-2 「计算机网络」前端必备知识，看到就是赚到系列（上）

https://mp.weixin.qq.com/s/iSZp41SRmh5b2bXIvzemIw  探究！一个数据包在网络中的心路历程

https://juejin.cn/post/6939691851746279437#heading-17 字节跳动最爱考的前端面试题：计算机网络基础

https://www.jianshu.com/p/3fc3646fad80 http的长连接和短连接（史上最通俗！）

https://blog.nowcoder.net/n/d5e2c1b0abf1416e8379c0c24eb3458a 前端复习企划7-网络
### 1. 网络模型
<!-- https://www.yuque.com/cuggz/interview/cdpgm0#NQHWi -->

https://www.yuque.com/cuggz/interview/cdpgm0#YhF2j

https://blog.nowcoder.net/n/d5e2c1b0abf1416e8379c0c24eb3458a

https://juejin.cn/post/6915362842212302862

![](image/2021-06-28-20-46-38.png)

![](image/2021-06-30-16-57-59.png)

### 2. tcp udp
https://www.cnblogs.com/xiaolincoding/p/12732052.html 30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制

https://www.cnblogs.com/xiaolincoding/p/12638546.html 被问千百遍的 TCP 三次握手和四次挥手面试题

[TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？](https://mp.weixin.qq.com/s/25atTs4b-vORIx525ur_aw)

### 3. 键⼊⽹址到⽹⻚显示，期间发⽣了什么
小林coding 5.1
https://blog.nowcoder.net/n/d5e2c1b0abf1416e8379c0c24eb3458a
https://juejin.cn/post/6902032954034225159#heading-7 加入了浏览器进程相关的过程
>注：域名解析过程就是DNS过程

### 4. HTTPS
对称加密
有点：快捷
缺点：需要维护密钥

非对称加密
优点：不用维护密钥
缺点：慢（要大素数计算）

为什么用混合加密，每次生成新的密钥：省的服务器保存和维护用户的对称密钥

### 4. 进程线程
小林coding 系统
>看 
[一文读懂什么是进程、线程、协程（建议收藏）](http://www.360doc.cn/article/32196507_906628857.html)

---
可以从四方面思考：
1.1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。
1.2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。
1.3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间。
1.4. 调度和切换：线程上下文切换比进程上下文切换要快得多。


### 5. CDN
http://hpoenixf.com/DNS%E4%B8%8ECDN%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB.html
https://juejin.cn/post/6844903906296725518#heading-2 漫话：如何给女朋友解释什么是CDN？
https://juejin.cn/post/6844904190913822727

### http

#### get和post
先说相同点，只有了解了相同点之后才能理解为什么会发生混淆。两者都能向服务器发送数据，提交的“内容”[注1]的格式相同，都是var_1=value_1&var_2=value_2&....get 和 post 区别如字面，一个是get（获取），一个是post（发送）。get用来告诉服务器需要获取哪些内容（uri+query），向静态页面（uri）请求则直接返回文件内容给浏览器，向一个动态页面**请求时可以提供查询参数（query）以获得相应内容**。post用来向服务器提交内容，**主要是为了提交**，而不是为了请求内容，就是说post的初衷并不要求服务器返回内容[注2]，只是提交内容让服务器处理（主要是存储或者处理之后再存储）。get和post出现混淆是因为对提交的数据处理方法的滥用造成的，数据是无辜的。

混淆之一：  将get提交的用来查询的字段当作是存储数据存入了服务器端文件或者数据库。然后就误以为get是用来提交用于存储的数据的。

混淆之二：  编写脚本在服务器端通过处理post提交的数据并返回内容。只要有数据，就能用来进行判断，脚本怎写是程序员的事，而不在乎数据来源的形式（post、get，或者是自己预设值的常量）。这点功能上确实没问题，只是背离的其初始目的而已。

由于都是要传送数据，且数据格式相同（即使数据格式不同，只要能提取出相应数据）。使用的时候难免出现张冠李戴，将get数据用来存储、将post数据用来检索返回数据。但是二者还是有区别的（主要是根据其用途而“人为”[注3]造成的），get的长度限制在2048字节（由浏览器和服务器限制的，这是目前IE的数据，曾经是1024字节），很大程度上限制了get用来传递“存储数据”的数据的能力，所以还是老老实实用来做检索吧；post则无此限制（只是HTTP协议规范没有进行大小限制，但受限于服务器的处理能力），因此对于大的数据（一般来说需要存储的数据可能会比较大，比2048字节大）的传递有天然的优势，谁让它是 nature born post 呢。

get提交的数据是放在url里，目的是灵活的向服务其提交检索请求，可以在地址栏随时修改数据以变更需要获取的内容，比如直接修改分页的编号就跳到另外一个分页了（当然也可能是 404）。post提交的数据放在http请求的正文里，目的在于提交数据并用于服务器端的存储，而不允许用户过多的更改相应数据（主要是相对于在url 修改要麻烦很多，url的修改只要点击地址栏输入字符就可以了），除非是专门跑来编辑数据的。

且get可以缓存。

花边：post和get的安全性在传输的层面上区别不大，但是采用url提交数据的get方式容易被人肉眼看到，或者出现在历史纪录里，还是可能被肉眼看到，都是一些本地的问题。

注1：我强调的是内容，至于http协议中的get和post的格式大家有兴趣就自己看看吧。

注2：get方式主要是为了获得预期内容，即uri+query相同时所得到的内容应该是相同的。而post主要是提交内容，至于是否有必要返回页面可能只是出于用户体验，比如注册时返回你的注册id，但是如果只是返回一个“您已注册成功”的相同页面（即使你post的数据不一样）也没什么好奇怪的。

注3：关于这个“人为”，不是那么贴切，get和post还是有技术层面的区别的。但是从表象上看暂且这么说吧，毕竟二者的混淆也是“人为”的。

#### post和put
POST方法和PUT方法请求最根本的区别是发起请求的目的不同。post 请求的目的是根据资源自身的语义来处理这个资源（译注：我理解这个意思就是说，post请求可以根据实际请求的资源来决定到底怎么处理，原文中4.3.3节给了一些例子。我会把我的翻译版附在本文末尾。）。put请求的目的是用来替换整个目标资源。**put 请求具有 幂等性**（idempotent）。（幂等性的意思在这个RFC的4.2.2里说了“同样的请求，不管发多少次，每次服务器处理完之后的结果，都和只发一次是一样的。”这里我举个例子帮助大家理解：你的服务器端存放了一个文章收藏夹，你通过一个put请求来修改收藏夹里的文章名字，这个 put 请求的请求体里包含了整个文章收藏夹里所有文章的名字。当服务端处理这个请求时，只要从 put 请求里拿出这个文章名字列表，整个存到服务器上，就是一个完整的新的收藏夹。那么这样的put 请求，无论你是发一次，还是发多次，假设服务器都能成功处理，那么最终对服务器造成的影响都是一样的：即服务器端原有的收藏夹里的文章列表被替换成了put请求里带的收藏夹的文章列表。）

1. 服务端在处理时post方法发出的请求时，应该按照请求的具体资源的具体语义来对该资源做相应的处理。例如，以下情况一般使用 Post 方法：

        提供一整块数据时，比如，向html表单的文本框里输入数据，然后把整个表单提交，来对这些数据做处理。
        在论坛、群组、邮件列表、博客或者类似的东西里发表文章时。
        想要通过请求在服务器端创建一个新资源时。
        像服务端的一个资源里插入一些数据时。

2. put方法用于创建或者替换整个资源，请求体（body）里包含这个资源的完整描述。一个 put 请求如果成功了，那么理论上来说，对同样的 url 做一个 get 请求，应该能得到一个 200 (OK) 的响应。但实际上，并不能保证get 到200的响应。因为，可能同时有其他人也在对这个资源做操作，那么就可能在get请求抵达服务器之前，这个资源已经被别人改掉了。所以说， put 请求成功，只能代表在这个请求被服务器处理的那个时刻上，这个资源被创建或替换成请求体里的样子了。（译注：比如我用put请求修改一个小组里的所有用户列表，我的请求体里包含了小组里所有用户的用户名列表，那么在服务器处理我这个请求，并告诉我成功了的那个时刻，这个小组的用户名一定和我发的put请求里的用户名列表是一样的。但是同时有可能有别的人也在尝试改这个小组的信息，那么我紧接着发一个 get 请求，可能get到的小组里的用户名列表跟我刚才put的已经不一样了。）

---
当需要以更新的形式来修改某一具体资源的时候，如何判断用PUT还是POST呢？

很简单，如果该更新对应的URI多次调用的结果一致，则PUT

比如更新某个blog文章，因为该文章具有单一的具体URI，所以每次更新提交相同的内容，结果都一致

/blog/{document_id}/update

在每次更新提交相同的内容，最终的结果不一致的时候，用POST

举个很常见的例子，一个接口的功能是将当前余额减一个值，每次提交指定该值为100，接口如下

/amount/deduction

调用一次，你的余额-100，调用两次，余额-200

这个时候就用POST